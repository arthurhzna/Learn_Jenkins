For example:

There is a branch `feature/login` with a PR to `main`.
Jenkins configuration:

Discover Branches: Exclude branches that are also filed as PRs.
Discover Pull Requests from Origin: The current pull request revision.

What happens?

Discover Branches: Exclude branches that are also filed as PRs:

Jenkins doesn't create a pipeline job for the `feature/login` branch because this branch has an open PR to `main`.
Only branches without a PR (for example, `main`, `develop`, or other branches without a PR) will have pipeline jobs created (for example, jobs named `main` or `develop`).

Discover Pull Requests from Origin: The current pull request revision:

Jenkins detects the PR from `feature/login` to `main` and creates a PR job (for example, `PR-123`).
This job builds the code from the latest commit on `feature/login` (the head revision), without a simulated merge into `main`.

Why is `feature/login` still built?

Yes, the code in `feature/login` is still built, but as a PR job (`PR-123`) rather than as a separate branch job (there is no job named `feature-login`).
This is the desired behavior: you want the PR to be tested (as part of the review process), but you don't want the `feature/login` branch built twice (once as a branch job, once as a PR job).

Why is this not "useless"?

The combination of "Exclude branches that are also filed as PRs" with "The current pull request revision" is not useless because the goal is to group and optimize builds to avoid duplication. Here are the specific reasons:

Avoiding Duplicate Builds:

If you don't use "Exclude branches that are also filed as PRs" and instead use "All branches", Jenkins will create two jobs for `feature/login`:

A branch job named `feature-login` (building the `feature/login` code).
A PR job named `PR-123` (also building the `feature/login` code, because "The current pull request revision" only builds the head revision of `feature/login`).

This means two identical builds for the same code, which wastes resources (CPU, memory, time) on the Jenkins server

-------------------
stage('Example') {
    steps {
        script {
            def myVar = "stage value"
            echo myVar  // ✅ works
            sh "echo ${myVar}"  // ✅ works
        }
    }
}

stage('Example') {
    steps {
        script {
            def myVar = "stage value"
        }
        script {
            echo myVar  // ❌ ERROR: myVar is not recognized
        }
    }
}

stage('Stage 1') {
    steps {
        script {
            def myVar = "stage 1 value"
        }
    }
}

stage('Stage 2') {
    steps {
        script {
            echo myVar  // ❌ ERROR: myVar is not recognized
        }
    }
}

environment {
    SHARED_VAR = ""
}

stage('Stage 1') {
    steps {
        script {
            env.SHARED_VAR = "shared value"
        }
    }
}

stage('Stage 2') {
    steps {
        script {
            echo env.SHARED_VAR  // ✅ works
        }
    }
}

def globalVar

stage('Stage 1') {
    steps {
        script {
            globalVar = "global value"
        }
    }
}

stage('Stage 2') {
    steps {
        script {
            echo globalVar  // ✅ works
        }
    }
}