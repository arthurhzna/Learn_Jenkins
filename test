pipeline {
  agent any

  environment {
    DOCKER_CREDENTIALS = credentials('docker-credential')
    GITHUB_CREDENTIALS = credentials('github-credential')
    SSH_KEY_CREDS = 'ssh-key'   
    HOST = credentials('host')
    USERNAME = credentials('username')
    TARGET = ''
    IMAGE_NAME = ''
    IMAGE_FULL = ''
    IMAGE_TAG = ''
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
        script {
          echo "BRANCH_NAME = ${env.BRANCH_NAME}"
        }
      }
    }

    stage('Set Target & Image') {
      steps {
        script {
          // map branch -> target & image name
          def b = env.BRANCH_NAME?.toLowerCase()
          if (b == 'develop' || b == 'development') {
            env.TARGET = 'dev'
            env.IMAGE_NAME = 'arthurhozanna/learn_jenkins_develop'
          } else if (b == 'staging' || b == 'stage') {
            env.TARGET = 'staging'
            env.IMAGE_NAME = 'arthurhozanna/learn_jenkins_staging'
          } else if (b == 'master' || b == 'main' || b == 'live') {
            env.TARGET = 'prod'
            env.IMAGE_NAME = 'arthurhozanna/learn_jenkins_prod'
          } else {
            // feature branches, PR branches -> map to dev by default
            env.TARGET = 'dev'
            env.IMAGE_NAME = 'arthurhozanna/learn_jenkins_develop'
          }

          // tag by short commit + build number for reproducibility
          def shortSha = (env.GIT_COMMIT ?: sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim())
          env.IMAGE_TAG = "${shortSha ?: 'local'}-${env.BUILD_NUMBER ?: '0'}"
          env.IMAGE_FULL = "${env.IMAGE_NAME}:${env.IMAGE_TAG}"

          echo "TARGET=${env.TARGET} IMAGE=${env.IMAGE_FULL}"
        }
      }
    }

    stage('Unit Test') {
      steps {
        script {
          // run unit tests for Go project
          sh 'go test ./...'
        }
      }
    }

    stage('Build & Push Image') {
      when {
        // skip build/push for PRs (multibranch PRs set env.CHANGE_ID)
        expression { return !env.CHANGE_ID }
      }
      steps {
        script {
          withCredentials([usernamePassword(credentialsId: 'docker-credential', usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
            sh """
              echo "${DOCKER_PASSWORD}" | docker login -u "${DOCKER_USERNAME}" --password-stdin
              docker build -t ${IMAGE_FULL} .
              docker push ${IMAGE_FULL}
            """
          }
        }
      }
    }

    stage('Deploy to Remote Host') {
      when {
        expression { return !env.CHANGE_ID } // hanya branch, bukan PR
      }
      steps {
        script {
          // gunakan ssh key credential (ssh-user-private-key) dan string creds HOST/USERNAME
          withCredentials([sshUserPrivateKey(credentialsId: env.SSH_KEY_CREDS, keyFileVariable: 'SSH_KEY_FILE', usernameVariable: 'SSH_USER')]) {
            // pastikan docker-compose.<target>.yaml di server menunjuk ke image: IMAGE_FULL (atau gunakan variable substitution)
            sh """
              ssh -o StrictHostKeyChecking=no -i ${SSH_KEY_FILE} ${USERNAME}@${HOST} '
                cd /path/to/app || exit 1
                # tarik image terbaru berdasarkan tag
                docker-compose -f docker-compose.${TARGET}.yaml pull || true
                docker-compose -f docker-compose.${TARGET}.yaml up -d --remove-orphans
              '
            """
          }
        }
      }
    }
  }

  post {
    always {
      echo "Finished pipeline for branch=${env.BRANCH_NAME} target=${env.TARGET} image=${env.IMAGE_FULL}"
    }
    failure {
      echo "Build failed for ${env.BRANCH_NAME}"
    }
  }
}